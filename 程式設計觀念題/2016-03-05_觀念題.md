## 2016-03-05_觀念題_試題下載
 - https://apcs.csie.ntnu.edu.tw/wp-content/uploads/2018/12/1050305APCSconcept.pdf

## Q01 - 追蹤程式碼 / 除錯
- 找出程式碼哪裡有錯，需要修改幾行
```C
#include  <stdio.h>

void main(void)
{
    int k = 4;
    int m = 1;
    for (int i=1; i<=5; i=i+1) {
        for (int j=1; j<=k; j=j+1) {
            printf (" ");
        }
        for (int j=1; j<=m; j=j+1) {
            printf ("*");
        }
        printf ("\n");
        k = k - 1;
        m = m + 2; // 需修改此行，星星遞增的序列是 1
    }
}
```
Ans: (A) 1

<br>

## Q02 - 陣列 / 索引
- 尋找陣列中，最大值的索引位置
  ```
  f(a, 10)
  = 從第1個掃到最後一個元素
    若有找到更大的值的話，就把 index 記下來
    目前初始的值，預設為a[0]=1
  = 回傳陣列中最大值的索引位置
  ```
- if (3 >= 1): index = 1
- if (9 >= 3): index = 2
- if (9 >= 9): index = 7

Ans: (C) 7

<br>

## Q03 - 函數分析與比較
- 比較兩個函數：一個是循序搜尋，另一個是二分搜尋
- 計算這兩個函數中，if 執行的次數
- a[] = {1, 4, 7, 10, 13, ..., 100, ..., 295, 298}
- a[33] = 100
- f1 執行過程：
  ```
  f1:
  a[0] = 1
  a[1] = 4
  a[2] = 7
  a[3] = 10
  ...
  a[33] = 100 ... 找到 a[33] = 100
  ```
  - 共執行 34 次
- f2 執行過程：
  ```
   0 < 99: mid = (0 + 99) / 2 = 49
   0 < 48: mid = (0 + 48) / 2 = 24
  25 < 48: mid = (25 + 48) / 2 = 36
  25 < 36: mid = (25 + 36) / 2 = 30
  30 < 36: mid = (30 + 36) / 2 = 33 ... 找到 a[33] = 100
  ```
  - 共執行 5 次
  
Ans: (D) n1=34, n2=5

<br>

## Q04 - 陣列 / 等差級數的和
- b值
  ```
  b[1] = 1
  b[2] = 2
  b[3] = 3
  b[4] = 4
  b[5] = 5
  ...
  b[100] = 100
  ```
- a 值
  ```
  a[0] = 0
  a[1] = b[1] + a[0] = 1 + 0 = 1
  a[2] = b[2] + a[1] = 2 + 1 = 3
  a[3] = b[3] + a[2] = 3 + 3 = 6
  a[4] = b[4] + a[3] = 4 + 6 = 10
  a[5] = b[5] + a[4] = 5 + 10 = 15
  ...
  觀察 a 序列，得到：
  累積索引值的結果(等差級數的加總)
  a[k] = k(1+k)/2
  ```
- a[50] = (1 + 50) / 2 x 50 = 1275
- a[30] = (1 + 30) / 2 x 30 = 465
- a[50] - a[30] = 1275 - 465 = 810

Ans: (D) 810

<br>

## Q05 - 遞迴 / 等比級數的和
- 觀察次數變化
  ```
  f(1000): 1000次
  f(1000x2/3=666): 666次
  f(666x2/3=444): 444次
  f(444x2/3=666): 296次
  ...
- 執行的總次數，其實就是等比級數的和
  ```
  S = a + ar + ar^2 + ar^3 + ar^4 + ...
  S = a * (r^n - 1) / (r - 1)
  ```
  首項 a =1000，公比 r = 2/3
  ```
  S = 1000 * ((2/3)^Inf - 1) / ((2/3) - 1)
    = 1000 * (0-1)/(1/3) 
    = 1000 * 3 
    = 3000
  ```
- 觀察實際結果
  ```
  f(1000): 1000 => 1000
  f(666): 666 => 1666
  f(444): 444 => 2110
  f(296): 296 => 2406
  f(197): 197 => 2603
  f(131): 131 => 2734
  f(87): 87 => 2821
  f(58): 58 => 2879
  f(38): 38 => 2917
  f(25): 25 => 2942
  f(16): 16 => 2958
  f(10): 10 => 2968
  f(6): 6 => 2974
  f(4): 4 => 2978
  f(2): 2 => 2980
  ```

Ans: (B) 3000

<br>

## Q06 - 鏈結串列
- 鏈結串列的移除操作
- ```A -> B -> C``` -> ```A -> C```
- 概念：```A->next = A->next->next```

Ans: (B) list[current].next = list[list[current].next].next ;

<br>

## Q07 - 遞迴 / 追蹤程式碼
- 遞迴函數計算
  ```
  a(13, 15)
  = a(12, 15) + 13
    > a(11, 15) + 12
      > a(10, 15) + 11
        > a(9, 15) + 10
  = a(9, 15) + (13 + 12 + 11 + 10)
  = a(9, 15) + 46
  
  a(9, 15)
  = a(9, 13) + 15
    > a(9, 11) + 13
      > a(9, 9) + 11
        > (9 + 9)
  = (9 + 9) + (11 + 13 + 15)
  = 18 + 39
  = 57
  
  a(13, 15) = a(9, 15) + 46 = 57 + 46 = 103
  ```
Ans: (B) 103

<br>

## Q08 - 演算法 / 動態規劃DP / 費氏數列 / Bottom-up 計算
```
a = 0, b = 1, 下一個數 c 如何計算? c=a+b

把 b 暫存起來：tmp = b
b = a + b
a = tmp
```
Ans: (C) (a) b = a + b (b) b

<br>

## Q09 - 追蹤程式碼
```
A
1: 2 + 1x4 = 6
2: 2 + 2x4 = 10
3: 2 + 3x4 = 14
4: 2 + 4x4 = 18

B
1: 1x5 = 5
2: 2x5 = 10
3: 3x5 = 15
4: 4x5 = 20

C = (A < B) ? 
6 < 5? c = 1
10 < 10? c = 1
14 < 15? c = c + B % A = 1 + 15 % 14 = 1 + 1 = 2
18 < 20? c = c + B % A = 2 + 20 % 18 = 2 + 2 = 4
```
Ans: (B) 4

<br>

## Q10 - 遞迴 / 追蹤程式碼
```
g(13)
= g(11) + 3
  > g(9) + 3
    > g(7) + 3
      > g(5) + 3
        > g(3) + 3
          > g(1) + 3
            = 1
= 1 + 3 x 6
= 19
```
Ans: (C) 19

<br>

## Q11 - 資料結構 / 排序 / 氣泡排序
- 元素倆倆互換
- 有 n 個元素，要進行 n - 1 互換
- 邊界從 0 開始的話，末端元素索引 n-1
  - 所以條件要設成 n-2，否則 a[i+1] = a[(n-1)+1] 會超出索引值
  
Ans: (D) n-2

<br>

## Q12 - 遞迴 / 追蹤程式碼
```
f1(1) ┬ 1
      ├ f2(3) ┬ 3
      └ 1     ├ f1(2) ┬ 2
              └ 3     ├ f2(4) - 4
                      └ 2
```
- (A) 印出的數字最大的是 4
- (B) f1 一共被呼叫二次
- (C) f2 一共被呼叫三次 ---> f2 一共被呼叫二次
- (D) 數字 2 被印出兩次

Ans: (C) f2 一共被呼叫三次

<br>

## Q13 - 演算法 / 輾轉相除法
GCD(i, j) = GCD(j, i%j)
```
remainder = i % j;

下一次計算：
i = j;
j = remainder
```
Ans: (A)

<br>

## Q14 - 遞迴 / 追蹤程式碼 / 餘數問題
```
foo(15106)
= bar(15106 - 10) = bar(15096)
= foo(15096 - 5) = foo(15091)

foo: 等效於參數一次少15
15106 = 15x1000 + 106 = 15x1000 + 15x6 + 16
減少到邊界進行測試

foo(15106)
= foo(16)
= bar(16 - 10) = bar(6) -> 輸出 bar: 6
```

```
bar(3091)
= foo(3091 - 5) = foo(3086)
= bar(3086 - 10) = bar(3076)

bar: 等效於參數一次少15
3091 = 15x200 + 91 = 15x200 + 15x5 + 16
減少到邊界進行測試

bar(3091)
= bar(16)
= foo(16 - 5) = foo(11)
= bar(11 - 10) = bar(1) -> 輸出 bar: 1
```
此時答案只剩一個，就是 (A)

繼續練習：
```
foo(6693)
= foo(15 x 44 + 93)
= foo(15 x 5 + 18)
= foo(18)
= bar(18 - 10) = bar(8) -> 輸出 bar: 8
```

Ans: (A)

<br>

## Q15 - 遞迴 / 追蹤程式碼 / 奇偶數問題
```
f(22)
out: 22
n = 22 / 2 = 11...out: 11
n = 3 x 11 + 1 = 34...out: 34
n = 34 / 2 = 17...out: 17
n = 3 x 17 + 1 = 52...out: 52
n = 52 / 2 = 26...out: 26
n = 26 / 2 = 13...out: 13
n = 3 x 13 + 1 = 40...out: 40
n = 40 / 2 = 20...out: 20
n = 20 / 2 = 10...out: 10
n = 10 / 2 = 5...out: 5
n = 3 x 5 + 1 = 16...out: 16
n = 16 / 2 = 8...out: 8
n = 8 / 2 = 4...out: 4
n = 4 / 2 = 2...out: 2
n = 2 / 2 = 1...out: 1
```
- 總共輸出 16 個數字
Ans: (A) 16

<br>

## Q16　追蹤程式碼 / if-else 問題
```
count=10
count=11
count=12
count=0
count=16
```
- ```(count % 3 == 4)``` 永遠是 false，因為餘數永遠比被除數小
Ans:　(D) 16

<br>

## Q17　- 陣列 / 追蹤程式碼 / 邊界資料測試
- for 迴圈沒有跳出，表示最後的條件判斷會是重點
- 11 12 13 14 25 20
  - 25 > 20
  - allBig = TRUE
  - 但實際上 11, 12, 13, 14 皆小於 20
Ans: (B) 11 12 13 14 25 20

<br>

## Q18
- 送分題
- 如果編譯器可以找到所有問題，那程式設計師就不用 debug 了
  - 從而得證「以上皆是」是錯誤的
Ans: (A) 語法錯誤

<br>

## Q19 - 陣列 / 記憶體位址
```
A[0][0] = 108
A[0][1] = 110
A[0][2] = 112
A[0][3] = 114
A[1][0] = 116
A[1][1] = 118
A[1][2] = 120
```
- 用列舉的，會比計算快上很多
Ans: (A) 120

<br>

## Q20　- 演算法 / N 階層 / 遞迴 / 追蹤程式碼
- 確認 n = 1 或 n = 0 的邊界條件
Ans: (B) 第 3 行，改為 if (n > 0) {

<br>

## Q21 - for迴圈 / 遞增條件
- i = i + 1 執行兩次
- i 值一次遞增 2
Ans: (A) 0 2 4 6 8 10

<br>

## Q22
<br>

## Q23
<br>

## Q24
<br>

## Q25
